从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染。

应用在运行的时候，需要根据状态的不断变化，而不断地进行重新渲染。

而响应式系统赋予框架重新渲染的能力，其核心是`变化侦测`。具有响应式的框架在运行时，视图会跟着状态的变化而变化。

此处的状态就是数据。即MVVM的核心就是数据驱动视图，视图变化，数据跟着变化。

**变化侦测的作用就是侦测数据的变化**。当数据变化时，会通知视图进行相应的更新。

# 1.1 Object的变化侦测

数据输出到页面上显示出来的过程叫`渲染`。而Vue.js的渲染过程是声明式的，我们通过模板来描述数据状态与DOM之间的映射关系。

通常，在运行时应用内部的状态会不断的变化，变化的同时，页面在不断的重新渲染。如何确定状态发生了什么变化，，就是变化侦测所需实现的功能了。

变化侦测通常有两种方式实现：一种是pull（拉），另一种是push(推)。

`两种变化侦测对比：`

- 优势：
  1. 在Angular和React的状态变化是通过pull方式，在状态发生变化的时候，它只知道状态可能发生变化，而不知道哪个地状态发生了变化，然后向会发送一个信号告诉框架，框架内部接收到信号后，会进行`**暴力比对**`来找出哪些DOM节点需要重新渲染。在Angular中，是通过`脏检查`的流程，而React是通过`虚拟DOM`。
  
  2. Vue的变化侦测是通过push。当状态发生变化的时候，VUE立即知道，并且在一定程度上知道哪些状态发生了变化。因此Vue比Angular和React能进行更细颗粒度的更新。也就是说，假如一个状态绑定了多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态变化的时候，会向这个状态的所有依赖发送通知，让它们进行更新重渲染的操作。
   
- 劣势：
  1. 颗粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的消耗就越大。
  
所有Vue在2.0版本的时候引入了虚拟DOM，将颗粒度调整到中等。即每个状态所绑定的不再是具体的DOM，而是一个组件。这样做的好处在于，当状态变化，不再通知到具体的DOM，而是通知到具体的组件，组件内部再通过虚拟DOM进行比对渲染。

`综上所述：`
1. Vue在2.0的版本是数据发生变化后立即通知到数据所绑定的依赖即组件上，组件通过虚拟DOM的diff算法，计算出变化的状态，再进行渲染；

2. Angular与React，是数据发现变化，通知整个框架，框架再通过暴力对比，查找出变化的数据对应的DOM节点，进行更新渲染。

# 1.2 如何追踪变化
在JavaScript中侦测一个对象的变化有两种方式： 1） `Object.defineProperty`；2）`Proxy`。

在Vue2.x版本是通过defineProperty实现的，但是当中有许多缺陷，一个最主要的的缺陷是不能侦测到Array数组的变化，不过可以用另外一种方式去实现，在下一章节再介绍。

不管是以何种方式实现的侦测变化，其核心原理不变。都是通过getter与setter监听。

```typescript
function defineReactive(data, key , val) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      return val;
    },
    set: function(v) {
      if (v === val) {
        return;
      }
      val = v;
    }
  })
}

```
这里是封装了一个响应式的数据的函数，这个函数的主要作用就是追踪变化。每当data中的key被读取的时候，getter函数被触发；当key被重置数据的时候，会触发setter方法。

# 1.3 如何收集依赖

侦测数据变化的目的在于当数据发生变化时，可以通知那些使用过该数据的地方，即要通知依赖（组件）。

怎么确定使用过该数据的地方，即访问过该数据。

怎么通知依赖，即设置过该数据。

`综上撰述：` **`在getter方法收集依赖，在setter方法中触发依赖`**
